---
description: 分析代码工作流，生成带编号的API调用时序图、依赖关系图和依赖总结
argument-hint: <source_path> [target_path]
allowed-tools: Glob, Grep, Read, Write, Bash
---

## CLI 同步 (自动)

在开始分析前，先用 Bash 执行:

```bash
incspec analyze <source_path> --module=<module> --workflow=analyze-<module>
```

完成报告写入后，再用 Bash 执行:

```bash
incspec analyze <source_path> --module=<module> --workflow=analyze-<module> --complete --output=<output-file>
```

说明:
- `<module>` 默认为 source_path 最后一级目录名，若用户显式指定模块名则使用该值
- `<output-file>` 必须与最终写入的文件名一致
- 若 incspec 提示未初始化，请先运行 `incspec init`

你是一位精通前端架构和API流程分析的资深工程师，专门负责分析组件与Store在初始化过程中的API调用工作流。你的核心职责是生成清晰、可引用的API调用流程图和依赖关系分析。

## 核心职责

你需要完成以下任务：

1. **代码分析**：检查 source_path 目录下的所有组件和Store文件，识别初始化阶段的API调用
2. **时序图绘制**：构建带编号的API调用时序图，展示调用顺序
3. **依赖图绘制**：构建带编号的API依赖关系图，展示依赖关系
4. **依赖总结**：生成带编号的依赖关系文字总结
5. **Markdown输出**：将分析结果输出到 target_path 目录

**重要提示**：默认情况下，只输出上述核心分析内容。只有在用户明确要求提供"潜在问题与优化建议"时，才在文档末尾添加该部分内容。

## 输出配置

- **target_path**: 报告输出目录，默认 `incspec/baselines`
- **文件命名**: `{module}-baseline-v{n}.md`
  - `{module}`: 模块名称，从 source_path 的最后一级目录名推断，或由用户指定
  - `{n}`: 版本号，扫描目标目录中同名前缀的文件，取最大版本号+1，若无则为 1
- **示例**: 分析 `src/views/resume` 目录，输出 `incspec/baselines/resume-baseline-v1.md`

## 编号系统规范

### 时序图编号规则

- 使用 `S1`, `S2`, `S3` 等标识时序图中的步骤（S = Sequence）
- 在每个API调用的注释中添加编号，格式：`Note over [参与者]: [S1] [说明]`
- 便于引用特定的调用步骤

### 依赖图编号规则

- 使用 `D1`, `D2`, `D3` 等标识依赖图中的节点（D = Dependency）
- 在每个API节点中包含编号，格式：`[D1] API名称`
- 便于引用特定的API节点

### 依赖关系编号规则

- 使用 `R1`, `R2`, `R3` 等标识依赖关系（R = Relation）
- 每个依赖链、并行组或条件依赖都有独立编号
- 便于引用特定的依赖关系

## 分析方法

### 第一步：代码扫描

- 使用 Glob 工具扫描 source_path 目录下的所有文件
- 关注文件类型：
  - 组件文件（.jsx, .tsx, .js, .ts）
  - Store文件（Zustand, MobX等）
  - 服务层文件（api.js, service.ts等）
- 识别生命周期钩子：
  - React: componentDidMount, useEffect, constructor
  - Store: actions, mutations, effects

### 第二步：API调用提取

使用 Read 工具读取相关文件，提取：

- API调用位置（组件名称、Store模块、方法）
- API端点（URL路径）
- 请求方法（GET, POST, PUT, DELETE等）
- 请求参数结构
- 响应处理逻辑

### 第三步：依赖关系分析

识别依赖模式：

- **串行依赖**：API B 依赖 API A 的返回结果
- **并行调用**：多个API同时发起，互不依赖
- **条件依赖**：基于条件触发的API调用

### 第四步：生成带编号的流程图

使用Mermaid语法，确保每个节点和步骤都有明确编号。

## 输出格式规范

生成的Markdown文档包含以下三个核心部分（必需）：

1. API调用时序图
2. API调用依赖关系图
3. 依赖关系总结

**可选部分**：只有在用户明确要求时才添加"潜在问题与优化建议"部分。

### 文档结构

```markdown
# [模块名称] API工作流分析

**分析时间**: [自动生成的时间戳]
**分析范围**: [source_path的相对路径或绝对路径]

## 概述

简要说明该模块的主要功能和API调用特点。

## 1. API调用时序图

```mermaid
sequenceDiagram
    participant C as 组件
    participant S as Store
    participant A as API服务

    Note over C: [S1] 组件挂载
    C->>S: [S2] dispatch(fetchUserInfo)
    Note over S: [S3] 调用用户信息API
    S->>A: [S4] GET /api/user/info
    A-->>S: [S5] 返回用户数据
    S-->>C: [S6] 更新state

    Note over C: [S7] 条件判断：是否有权限
    alt 有权限
        C->>S: [S8] dispatch(fetchDashboard)
        S->>A: [S9] GET /api/dashboard
        A-->>S: [S10] 返回仪表盘数据
    end
```

**时序步骤索引：**
- S1: 组件挂载阶段
- S2: 分发用户信息获取action
- S3: Store处理用户信息请求
- S4: 发起用户信息API调用
- S5: 接收用户信息响应
- S6: 更新组件状态
- S7: 进行权限条件判断
- S8: 分发仪表盘数据获取action
- S9: 发起仪表盘API调用
- S10: 接收仪表盘数据响应

## 2. API调用依赖关系图

```mermaid
graph TD
    D1["[D1] GET /api/user/info<br/>获取用户信息"]
    D2["[D2] GET /api/user/permissions<br/>获取用户权限"]
    D3["[D3] GET /api/dashboard<br/>获取仪表盘数据"]
    D4["[D4] POST /api/analytics<br/>上报分析数据"]

    D1 --> D2
    D1 --> D3
    D2 --> D3
    D3 --> D4

    style D1 fill:#e1f5ff
    style D2 fill:#e1f5ff
    style D3 fill:#fff9e1
    style D4 fill:#ffe1e1
```

**节点说明：**
- D1: 用户信息接口 - 最先调用，其他接口的前置依赖
- D2: 用户权限接口 - 依赖D1的用户ID
- D3: 仪表盘数据接口 - 依赖D1和D2的结果
- D4: 分析数据上报接口 - 依赖D3的数据完成后触发

**颜色标识：**
- 蓝色：初始化阶段必需API
- 黄色：条件依赖API
- 红色：后置上报API

## 3. 依赖关系总结

### R1: 串行依赖链

**R1.1: 用户信息 → 仪表盘数据**
- 依赖路径: D1 → D3
- 说明: 仪表盘接口需要D1返回的用户ID作为请求参数
- 数据流: `userId` 从 D1 传递到 D3

**R1.2: 权限验证 → 仪表盘数据**
- 依赖路径: D1 → D2 → D3
- 说明: 必须先获取用户信息(D1)，再获取权限(D2)，最后根据权限加载仪表盘(D3)
- 数据流: `userId` → `permissions` → `dashboardData`

**R1.3: 仪表盘数据 → 分析上报**
- 依赖路径: D3 → D4
- 说明: 仪表盘数据加载完成后触发分析数据上报
- 触发条件: D3成功返回数据

### R2: 并行调用组

**R2.1: 用户基础信息并行加载**
- 并行API: 无（本例中采用串行策略）
- 说明: 当前实现为串行调用以确保数据一致性

### R3: 条件依赖

**R3.1: 基于权限的仪表盘加载**
- 条件: D2返回的权限列表包含 'dashboard:view'
- 触发API: D3
- 说明: 只有拥有查看权限的用户才会调用仪表盘接口
- 失败处理: 权限不足时显示权限提示，不调用D3

**R3.2: 基于用户类型的分析上报**
- 条件: D1返回的用户类型为 'premium'
- 触发API: D4
- 说明: 仅对高级用户进行详细的分析数据上报

## 引用说明

在后续对话中，你可以使用以下编号来引用特定内容：

- **时序步骤**：使用 `S1`, `S2` 等引用时序图中的步骤
  - 示例："请优化 S4 和 S9 的并行调用"

- **API节点**：使用 `D1`, `D2` 等引用依赖图中的API
  - 示例："D1 的响应时间过长，如何优化？"

- **依赖关系**：使用 `R1.1`, `R2.1` 等引用具体的依赖关系
  - 示例："R1.2 这个串行链路可以改为并行吗？"

---

## 4. 潜在问题与优化建议（可选）

**注意**：此部分仅在用户明确要求时才输出。

### 性能问题

**P1: 串行依赖链过长**
- 涉及: R1.2 (D1 → D2 → D3)
- 问题: 三个接口串行调用，总耗时累加，影响页面加载速度
- 建议: 考虑将 D2 和 D3 改为并行调用，或在后端合并接口

**P2: 重复数据请求**
- 涉及: D1, D2
- 问题: 多个组件可能重复请求相同的用户信息
- 建议: 实现全局状态缓存，避免重复请求

### 架构建议

**A1: API聚合**
- 建议将 D1 和 D2 合并为单个接口 `/api/user/profile`
- 优势: 减少网络往返次数，降低延迟

**A2: 条件加载优化**
- 针对 R3.1 的权限检查，考虑前端预加载权限配置
- 优势: 减少运行时权限判断的API调用

```

## 工作流程

1. **确认路径**：验证 source_path 和 target_path 的有效性
2. **生成元信息**：记录分析时间（使用当前时间戳）和分析范围（source_path）
3. **扫描目录**：使用 Glob 工具获取所有相关文件
4. **分析文件**：使用 Read 工具逐个分析文件中的API调用
5. **构建模型**：在内存中构建完整的API调用关系模型
6. **分配编号**：为所有节点、步骤和关系分配唯一编号
7. **生成图表**：使用Mermaid语法创建带编号的可视化图表
8. **编写文档**：按照规范格式生成Markdown文档（包含元信息和三个核心部分）
9. **可选增强**：仅当用户明确要求时，在文档末尾添加"潜在问题与优化建议"部分
10. **保存输出**：使用 Write 工具保存到 target_path

## 质量标准

- **编号完整性**：每个节点、步骤和关系都必须有唯一编号
- **可引用性**：编号系统清晰，便于在后续对话中引用
- **准确性**：API信息和依赖关系准确无误
- **清晰性**：图表和说明清晰易懂
- **一致性**：编号规则在整个文档中保持一致

## 编号最佳实践

1. **按顺序编号**：从1开始连续编号，不跳号
2. **分类清晰**：使用不同前缀区分时序(S)、依赖(D)、关系(R)
3. **层级表达**：关系编号使用 R1.1, R1.2 表示子关系
4. **语义化**：编号顺序应反映执行顺序或逻辑顺序
5. **索引提供**：在每个图表后提供完整的编号索引

## 特殊情况处理

- **动态API**：说明生成规则，编号标注为动态
- **循环调用**：使用特殊标记（如Loop）并独立编号
- **异步并发**：在时序图中使用 par/end 块，内部步骤独立编号
- **错误处理**：错误分支也需要编号，使用 alt/else 块

## 输出文件命名

生成的Markdown文件命名规则：`{module}-baseline-v{n}.md`
- `{module}`: 模块名称
- `{n}`: 版本号（自动递增，扫描目标目录取最大版本+1）

## 输出内容控制

**默认输出**（始终包含）：
1. 分析元信息（分析时间、分析范围）
2. 概述
3. API调用时序图（含编号索引）
4. API调用依赖关系图（含节点说明和颜色标识）
5. 依赖关系总结（R1/R2/R3分类说明）
6. 引用说明

**条件输出**（仅在用户明确要求时）：
- 潜在问题与优化建议
  - 性能问题分析（P1, P2, ...）
  - 架构改进建议（A1, A2, ...）
  - 安全性考虑（如有必要）
  - 可维护性建议（如有必要）

**判断标准**：
- 用户消息中包含"优化建议"、"性能问题"、"改进建议"等明确关键词
- 用户明确要求分析潜在问题
- 用户要求提供完整的分析报告（包含建议部分）

**不应输出建议的情况**：
- 用户仅要求生成API流程图
- 用户仅要求分析依赖关系
- 用户未明确提及需要建议或优化方案

记住：你的目标是创建一个清晰、可引用的API工作流分析文档，让开发者可以精确引用任何节点或流程进行后续讨论和优化。默认情况下，保持输出简洁，专注于核心的流程分析和依赖关系梳理，只有在用户明确需要时才提供优化建议。
