---
description: 将增量需求报告融合为新的代码流基线快照
argument-hint: <increment-report-path> [baseline-output-dir]
allowed-tools: Read, Write, Bash
---

## CLI 同步 (自动)

**检测工作流模式:**

```bash
incspec status
```

### 完整模式 (7步)

开始执行前，先用 Bash 执行:

```bash
incspec merge <increment-report-path>
```

完成基线报告写入后，再用 Bash 执行:

```bash
incspec merge <increment-report-path> --complete --output=<output-file>
```

说明:
- `<output-file>` 必须与最终写入的文件名一致
- 若提示没有活跃工作流，请先完成步骤 1-5

### 快速模式 (5步)

快速模式下，不依赖增量设计报告，直接重新分析当前代码生成新基线：

```bash
incspec merge --complete --output=<output-file>
```

说明:
- 快速模式下无需提供增量设计报告路径
- 实际执行的是对当前代码的重新分析
- 请先完成步骤 1-2 和步骤 5 (应用代码变更)

# 角色定位

你是增量基线融合专家。根据工作流模式执行不同的融合策略。

## 模式说明

- **完整模式**: 将增量需求融合快照报告（步骤 4 产出）转换为干净的基线快照报告
- **快速模式**: 重新分析当前代码状态（已应用变更后），生成新版本基线快照

# 核心目标

将增量报告中的"规划后状态"转换为"当前基线状态"：
- 提取增量报告的模块3（规划后的API调用时序图）和模块4（规划后的依赖关系图）
- 移除所有增量标记（🆕 新增、✏️ 修改、❌ 删除）
- 删除已标记为删除的节点
- 重新编号所有节点，使用基线编号系统（S1, S2... 和 D1, D2...）
- 生成符合 analyze-codeflow 格式的新基线报告

# 输入参数

1. **increment-report-path** (必填): 增量需求融合快照报告的完整路径（如 increment-codeflow-v2.md）
2. **baseline-output-dir** (可选): 新基线报告的输出路径，默认为 `<原文件名>-baseline.md`

# 执行流程

## 步骤 1: 读取并解析增量报告

读取 increment-report-path 指定的报告文件，提取以下模块：

- **模块 3: 规划后的 API 调用时序图**
  - 识别所有步骤节点及其标记
  - 识别 🆕 新增步骤 [N1], [N2]...
  - 识别 ✏️ 修改步骤 [S1-Modified], [S2-Modified]...
  - 识别 ❌ 删除步骤 [S3-Deleted]...
  
- **模块 4: 规划后的依赖关系图**
  - 识别所有依赖节点及其标记
  - 识别 🆕 新增节点 N1, N2...
  - 识别 ✏️ 修改节点 D1_MOD, D2_MOD...
  - 识别 ❌ 删除节点 D3_DEL...

## 步骤 2: 清理增量标记

### 2.1 处理时序图（模块3）

1. **移除删除节点**: 删除所有标记为 ❌ 的步骤及相关的 Note
2. **移除标记符号**: 
   - 移除所有 🆕、✏️、❌ emoji
   - 移除节点编号中的 -Modified、-Deleted 后缀
3. **统一节点编号**: 
   - 将所有节点（包括原有的 [S1]、新增的 [N1]、修改的 [S2-Modified]）重新编号
   - 按时序顺序统一编号为 [S1], [S2], [S3]...
4. **清理注释**: 移除说明新增/修改/删除的 Note 内容

### 2.2 处理依赖图（模块4）

1. **移除删除节点**: 删除所有标记为 ❌ 的节点及相关依赖关系
2. **移除标记符号**:
   - 移除所有 🆕、✏️、❌ emoji
   - 移除节点编号中的 _MOD、_DEL 后缀
3. **统一节点编号**:
   - 将所有节点（包括原有的 D1、新增的 N1、修改的 D2_MOD）重新编号
   - 按逻辑顺序统一编号为 D1, D2, D3...
4. **清理样式标记**: 
   - 移除虚线箭头（-.->），统一为实线箭头（-->）
   - 移除特殊颜色标记（如 #90EE90 绿色、#FFB6C1 粉色等）
   - 统一使用基线样式（蓝色 #e1f5ff、黄色 #fff9e1、红色 #ffe1e1）

### 2.3 重新生成依赖关系总结

基于清理后的依赖图，重新生成依赖关系总结：
- 重新分析串行依赖链（R1系列）
- 重新分析并行调用组（R2系列）
- 重新分析条件依赖（R3系列）
- 所有描述使用当前时态，移除"新增"、"修改"等增量术语

## 步骤 3: 生成基线报告

按照 analyze-codeflow.md 的输出格式生成新基线报告：

### 3.1 文档结构

```markdown
# [模块名称] API工作流分析

**分析时间**: [当前时间戳]
**分析范围**: [从原报告中提取或推断]
**基线版本**: 由增量报告 [原报告名称] 融合生成

## 概述

[从原报告中提取概述，移除增量相关描述]

## 1. API调用时序图

```mermaid
[清理后的时序图，使用 S1, S2, S3... 编号]
```

**时序步骤索引：**
- S1: [步骤描述]
- S2: [步骤描述]
...

## 2. API调用依赖关系图

```mermaid
[清理后的依赖图，使用 D1, D2, D3... 编号]
```

**节点说明：**
- D1: [API描述]
- D2: [API描述]
...

**颜色标识：**
- 蓝色：初始化阶段必需API
- 黄色：条件依赖API
- 红色：后置上报API

## 3. 依赖关系总结

### R1: 串行依赖链
...

### R2: 并行调用组
...

### R3: 条件依赖
...

## 引用说明

在后续对话中，你可以使用以下编号来引用特定内容：

- **时序步骤**：使用 `S1`, `S2` 等引用时序图中的步骤
- **API节点**：使用 `D1`, `D2` 等引用依赖图中的API
- **依赖关系**：使用 `R1.1`, `R2.1` 等引用具体的依赖关系
```

### 3.2 编号映射记录

在文档末尾添加一个隐藏的映射表（注释形式），记录原增量编号到新基线编号的映射关系：

```markdown
<!--
编号映射记录（供内部参考）:

时序图映射:
S1 (旧基线) -> S1 (新基线)
N1 (新增) -> S2 (新基线)
S2-Modified (修改) -> S3 (新基线)
S3-Deleted (删除) -> 已移除
...

依赖图映射:
D1 (旧基线) -> D1 (新基线)
N1 (新增) -> D2 (新基线)
D2_MOD (修改) -> D3 (新基线)
D3_DEL (删除) -> 已移除
...
-->
```

## 步骤 4: 验证与输出

### 4.1 一致性验证

1. **编号连续性**: 确保 S1, S2, S3... 和 D1, D2, D3... 编号连续无跳号
2. **引用完整性**: 确保依赖关系总结中引用的节点编号都存在
3. **语法正确性**: 验证 Mermaid 图表语法正确

### 4.2 输出摘要

```
✅ 增量基线融合已完成

📊 融合统计:
- 原有节点: X 个
- 新增节点: Y 个（已融合）
- 修改节点: Z 个（已融合）
- 删除节点: W 个（已移除）
- 新基线总节点: N 个

📁 输出文件:
  ✓ <baseline-output-dir>

🔄 下一步操作:
1. 检查新基线报告的完整性
2. 将此基线作为下一轮增量分析的起点
3. 后续增量分析时使用此基线进行对比
```

# 编号重分配策略

## 时序图编号策略

1. **保留原有步骤**: 未被删除且未被修改的原有步骤保持原编号
2. **融合新增步骤**: 新增步骤按时序位置插入
3. **融合修改步骤**: 修改步骤保持原位置编号
4. **移除删除步骤**: 删除步骤完全移除
5. **重新排序**: 按时序顺序重新编号 S1, S2, S3...

**示例**:
```
原基线: S1 -> S2 -> S3 -> S4
增量: S1 (保留) -> N1 (新增) -> S2-Modified (修改) -> S3-Deleted (删除) -> S4 (保留)
新基线: S1 -> S2 -> S3 -> S4
映射: S1->S1, N1->S2, S2-Modified->S3, S3-Deleted->移除, S4->S4
```

## 依赖图编号策略

1. **按拓扑排序**: 优先按依赖层级排序（无依赖的优先）
2. **同层按逻辑顺序**: 同一层级的节点按业务逻辑顺序
3. **保持主流程连续**: 主要调用链的节点编号尽量连续

# 处理特殊情况

## 情况1: 删除节点有依赖关系

如果被删除的节点 D3_DEL 有其他节点依赖它：
1. 在输出摘要中警告此问题
2. 在新基线报告的注释中标注此问题
3. 建议用户检查增量报告的合理性

## 情况2: 修改节点改变了依赖关系

如果修改节点（如 D2_MOD）改变了依赖关系：
1. 使用修改后的依赖关系（以虚线箭头为准）
2. 在新基线中转换为实线箭头
3. 重新生成依赖关系总结以反映新的依赖

## 情况3: 编号冲突

如果原有编号与新增编号冲突：
1. 优先保留原有节点的编号
2. 新增节点使用下一个可用编号
3. 确保最终编号连续

## 情况4: 缺少必要的上下文信息

如果增量报告中缺少必要的上下文信息（如API的详细描述）：
1. 尽量从现有信息推断
2. 在输出摘要中标注需要补充的信息
3. 建议用户手动完善基线报告

# 输出规范

## 输出目录

- **baseline-output-dir**: 默认为 `incspec/baselines`
- 如目录不存在,需主动创建

## 文件命名

- 命名规则: `{module}-baseline-v{n}.md`
  - `{module}`: 模块名称,从输入的增量报告文件名中提取(去除 `-increment-v{x}` 后缀)
  - `{n}`: 版本号,扫描目标目录中同名前缀的文件,取最大版本号+1
- 示例: 输入 `batch-operation-increment-v1.md` -> 输出 `batch-operation-baseline-v2.md`

## 风格一致性

确保新基线报告与 analyze-codeflow.md 生成的报告风格完全一致：
- 使用相同的 Mermaid 图表样式
- 使用相同的颜色标识规范（蓝色 #e1f5ff、黄色 #fff9e1、红色 #ffe1e1）
- 使用相同的章节结构
- 使用相同的编号系统（S系列、D系列、R系列）
- 不包含"潜在问题与优化建议"部分（除非原增量报告中有明确要求）

## 元信息标注

在新基线报告的开头添加元信息：
```markdown
**分析时间**: [当前时间戳]
**分析范围**: [从原报告中提取]
**基线版本**: 由增量报告 [原报告名称] 融合生成
```

# 错误处理

遇到以下情况时报错并中止：

1. increment-report-path 文件不存在
2. 报告缺少模块3或模块4
3. Mermaid 图表语法解析失败
4. 发现循环依赖问题（删除节点导致）
5. 编号系统无法重建（节点关系混乱）

错误时提供详细说明和修复建议。

# 质量保证

1. **完整性**: 确保所有未删除的节点都出现在新基线中
2. **正确性**: 确保依赖关系与时序逻辑一致
3. **可读性**: 确保图表清晰，说明准确
4. **可追溯性**: 保留编号映射记录，方便问题追溯
5. **风格统一性**: 与 analyze-codeflow 输出完全一致

# 最佳实践

1. **仔细解析**: 准确识别增量报告中的所有标记和编号
2. **逻辑验证**: 确保删除节点后依赖关系仍然合理
3. **编号优化**: 重新编号时保持逻辑连贯性
4. **文档清晰**: 生成的基线报告应该像原生分析结果一样自然
5. **保留映射**: 编号映射记录便于后续问题追溯

---

记住：你的目标是生成一个干净的、无增量标记的基线快照报告，它应该看起来就像是对当前代码直接执行 analyze-codeflow 分析得到的结果，为下一轮增量迭代提供可靠的对比基准。

---

# 快速模式执行流程

快速模式下，合并步骤实际是"重新分析"：不依赖增量设计报告，而是直接分析当前代码状态生成新基线。

## 核心区别

| 对比项 | 完整模式 | 快速模式 |
|-------|---------|---------|
| 输入文件 | 增量设计报告 | 无（直接分析代码） |
| 执行逻辑 | 清理增量标记、重新编号 | 重新执行 analyze-codeflow |
| 产出 | 融合后的基线 | 全新的基线快照 |

## 执行步骤

### 步骤 1: 确认代码变更已完成

确保步骤 5 (应用代码变更) 已完成，代码库处于变更后的状态。

### 步骤 2: 获取分析范围

从当前工作流状态中获取：
- 原始分析的源代码路径 (source-path)
- 模块名称 (module)

### 步骤 3: 重新执行代码分析

使用 analyze-codeflow.md 的分析方法，对当前代码状态进行完整分析：

1. **扫描代码目录**: 识别所有组件、Store、API 调用
2. **构建时序图**: 生成新的 API 调用时序图（S1, S2, S3...）
3. **构建依赖图**: 生成新的依赖关系图（D1, D2, D3...）
4. **总结依赖关系**: 生成新的依赖关系总结（R1, R2, R3...）

### 步骤 4: 输出新基线

- **输出目录**: `incspec/baselines/`
- **文件命名**: `{module}-baseline-v{n+1}.md`（版本号递增）
- **元信息**: 标注为"由快速模式工作流生成"

### 步骤 5: 输出摘要

```
✅ 快速模式基线生成已完成

📊 分析统计:
- 时序步骤: X 个 (S1-SX)
- 依赖节点: Y 个 (D1-DY)
- 依赖关系: Z 组 (R1-RZ)

📁 输出文件:
  ✓ incspec/baselines/{module}-baseline-v{n+1}.md

🔄 下一步操作:
1. 检查新基线报告的完整性
2. 运行 `incspec archive --yes` 归档当前工作流
3. 此基线将作为下一轮增量分析的起点
```
